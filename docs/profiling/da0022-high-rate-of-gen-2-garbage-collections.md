---
title: "DA0022: Gen 2 가비지 수집의 비율이 높습니다. | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-debug"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.performance.DA0022"
  - "vs.performance.rules.DA0022"
  - "vs.performance.22"
ms.assetid: f871a547-0e6f-4b11-b2d7-174d30fc2ed8
caps.latest.revision: 8
caps.handback.revision: 8
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
---
# DA0022: Gen 2 가비지 수집의 비율이 높습니다.
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

|||  
|-|-|  
|규칙 ID|DA0022|  
|범주|.NET Framework 사용|  
|프로파일링 방법|모두|  
|메시지|상대적으로 높은 비율의 Gen 2 가비지 수집이 발생하고 있습니다.  디자인상 프로그램의 데이터 구조가 대다수 오랜 시간 동안 할당되고 지속되는 경우 일반적으로 이러한 현상은 문제가 되지 않습니다.  하지만 이러한 동작이 의도되지 않은 경우에는 응용 프로그램이 개체를 고정하고 있는 것일 수 있습니다.  확실하지 않으면 .NET 메모리 할당 데이터 및 개체 수명 정보를 수집하여 응용 프로그램이 사용하는 메모리 할당 패턴을 파악할 수 있습니다.|  
|규칙 유형|경고|  
  
 샘플링, .NET 메모리 또는 리소스 경합 방법을 사용하여 프로파일링하는 경우에는 적어도 10개의 샘플을 수집하여 이 규칙을 트리거해야 합니다.  
  
## 원인  
 프로파일링 중 수집된 시스템 성능 데이터가 .NET Framework 개체에 대한 메모리의 상당 비율이 0세대 및 1세대가 아니라 2세대 가비지 수집에서 회수되었음을 나타냅니다.  
  
## 규칙 설명  
 Microsoft .NET CLR\(공용 언어 런타임\)에서는 가비지 수집기를 사용하여 응용 프로그램이 더 이상 사용하지 않는 개체에서 메모리를 회수하는 자동 메모리 관리 메커니즘을 제공합니다.  가비지 수집기는 많은 할당의 수명이 짧다는 가정에 따른 세대 기반 기능입니다.  지역 변수 등은 수명이 짧아야 합니다.  새로 만들어진 개체는 0세대\(Gen 0\)에서 시작된 후 가비지 수집 실행 시 수집되지 않으면 1세대로 진행되었다가 응용 프로그램이 여전히 해당 개체를 사용할 경우 마지막으로 2세대로 전환됩니다.  
  
 0세대에 있는 개체는 자주 수집되며 일반적으로 매우 효율적으로 수집됩니다.  1세대에 있는 개체는 수집되는 빈도가 적으며 덜 효율적으로 수집됩니다.  마지막으로, 2세대에 있는 수명이 긴 개체는 더 적은 빈도로 수집되어야 합니다.  완전 가비지 수집 실행인 2세대 수집은 가장 부담이 큰 작업이기도 합니다.  
  
 이 규칙은 2세대 가비지 수집이 비율적으로 너무 많이 수행되는 경우에 발생합니다.  올바르게 작동하는 .NET Framework 응용 프로그램에서는 1세대 가비지 수집이 2세대 수집보다 5배 이상 발생합니다. 10배는 이상적인 비율입니다.  
  
## 경고를 조사하는 방법  
 오류 목록 창에서 메시지를 두 번 클릭하여 프로파일링 데이터의 [표시 뷰](../profiling/marks-view.md)로 이동합니다.  **.NET CLR Memory\\\# Gen 0 Collections** 및 **.NET CLR Memory\\\# Gen 1 Collections** 열을 찾습니다.  프로그램 실행 단계 중 가비지 수집이 특히 빈번하게 발생하는 특정 단계가 있는지 확인합니다.  이 값을 **% Time in GC** 열과 비교하여 관리되는 메모리 할당의 패턴으로 인해 메모리 관리 오버헤드가 지나치게 증가하는지 확인합니다.  
  
 2세대 가비지 수집의 비율이 높다고 해서 항상 문제가 되는 것은 아닙니다.  이는 의도된 것일 수도 있습니다.  실행 중 오랜 기간 동안 활성 상태여야 하는 대형 데이터 구조를 할당하는 응용 프로그램에서 이 규칙이 발생할 수 있습니다.  이러한 응용 프로그램에서 메모리 사용량이 많아지면 가비지 수집이 빈번하게 수행될 수 있습니다.  부담이 적은 0세대 및 1세대 가비지 수집에서 적은 양의 관리되는 메모리만 회수할 수 있는 경우 2세대 가비지 수집이 보다 빈번하게 예약됩니다.  
  
 표시 뷰에는 가비지 수집 문제를 확인하는 데 유용한 추가 .NET CLR Memory 열이 있습니다.  **% Time in GC** 열은 얼마나 많은 메모리 관리 오버헤드가 발생하는지를 파악하는 데 유용합니다.  응용 프로그램에서 일반적으로 아주 적은 수의 대형 지속 개체를 사용하는 경우 2세대 수집이 빈번하더라도 CPU 시간이 지나치게 사용되지 않아야 합니다.  더 많은 실제 메모리\(RAM\)가 필요해서 응용 프로그램의 메모리 사용량이 늘어나는 경우에는 **Memory\\Pages\/sec** 열 값을 평가하는 관련 규칙도 발생할 수 있습니다.  
  
 응용 프로그램의 관리되는 메모리 사용 패턴을 파악하려면 .NET 메모리 할당 프로필을 실행하여 응용 프로그램을 다시 프로파일링하고 개체 수명 프로파일링 옵션을 선택합니다.  
  
 가비지 수집 성능을 향상시키는 방법에 대한 자세한 내용은 Microsoft 웹 사이트의 [가비지 수집기 기본 및 성능 힌트](http://go.microsoft.com/fwlink/?LinkId=148226) 를 참조하십시오.  자동 가비지 수집의 오버헤드에 대한 자세한 내용은 [대형 개체 힙 살펴보기](http://go.microsoft.com/fwlink/?LinkId=177836)를 참조하십시오.