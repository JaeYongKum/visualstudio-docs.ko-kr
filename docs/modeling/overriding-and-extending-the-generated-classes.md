---
title: "생성된 클래스 재정의 및 확장 | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "도메인별 언어, 재정의 가능한 클래스 제공"
ms.assetid: 30baa60d-a8ea-4611-96c1-8fcc3317cf21
caps.latest.revision: 15
author: "alancameronwills"
ms.author: "awills"
manager: "douge"
caps.handback.revision: 15
---
# 생성된 클래스 재정의 및 확장
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

DSL 정의의 강력한 도메인 관련 언어를 기반으로 하는 도구 집합을 만드는 데는 플랫폼입니다.  재정의 하 고 DSL 정의에서 생성 된 클래스를 확장 하 여 많은 확장 및 조정 작업을 수행할 수 있습니다.  이러한 클래스, DSL 정의 다이어그램에 명시적으로 정의 된 도메인 클래스 뿐 아니라 하지만 도구 상자, 탐색기, serialization, 등을 정의 하는 클래스를 포함 합니다.  
  
## 확장 가능 메커니즘  
 생성 된 코드를 확장할 수 있도록 여러 가지 메커니즘을 제공 합니다.  
  
### Partial 클래스 메서드를 재정의합니다.  
 Partial 클래스 정의 둘 이상의 위치를 정의 하는 클래스를 허용 합니다.  생성 된 코드를 직접 작성 하는 코드에서 분리할 수 있습니다.  수동으로 작성 된 코드에서 생성 된 코드에 의해 상속 된 클래스를 재정의할 수 있습니다.  
  
 예를 들어, DSL 정의에 명명 된 도메인 클래스를 정의 하는 경우 `Book`를 재정의 메서드를 추가 하는 사용자 지정 코드를 작성할 수 있습니다.  
  
 `public partial class Book`  
  
 `{`  
  
 `protected override void OnDeleting()`  
  
 `{`  
  
 `MessageBox.Show("Deleting book " + this.Title);`  
  
 `base.OnDeleting();`  
  
 `} }`  
  
> [!NOTE]
>  생성 된 클래스의에서 메서드를 재정의 하려면 항상 코드에서 생성 된 파일 구분 된 파일에 작성 합니다.  일반적으로 파일 CustomCode 라는 이름의 폴더에 포함 되어 있습니다.  생성 된 코드를 변경 하는 경우 DSL 정의에서 코드를 다시 생성 하는 경우는 손실 됩니다.  
  
 재정의할 수 있는 메서드를 검색 하려면 종류를 공백을 클래스에서 재정의 합니다.  IntelliSense 도구는 방법을 재정의 될 수 있습니다 알려 줍니다.  
  
### 이중에서 파생 된 클래스  
 생성 된 클래스의 메서드에 대부분 고정 된 집합의 모델링 네임 스페이스의 클래스에서 상속 됩니다.  그러나 일부 메서드는 생성 된 코드에서 정의 됩니다.  일반적으로이 재정의할 수 없습니다 의미 합니다. 같은 클래스의 다른 부분 정의에서 정의 된 메서드가 하나 partial 클래스에서 재정의할 수 없습니다.  
  
 그럼에도 불구 하 고 설정 하 여 이러한 메서드를 재정의할 수 있습니다의  **생성 이중 파생 된** 도메인 클래스에 대 한 플래그입니다.  생성 될이 원인이 두 개의 클래스, 하나 되는 추상 기본 클래스의 다른.  기본 클래스의 메서드 및 속성 정의 되 고 파생된 클래스의 생성자만 있습니다.  
  
 예를 들어, Library.dsl, 샘플에에서는 `CirculationBook` 도메인 클래스는 `Generates``Double Derived` 속성을 설정 `true`.  해당 도메인 클래스에 대해 생성 된 코드에는 두 개의 클래스가 들어 있습니다.  
  
-   `CirculationBookBase`에서 요약 된 및 모든 메서드 및 속성을 포함 합니다.  
  
-   `CirculationBook`에서 파생 된 `CirculationBookBase`.  해당 생성자를 제외 하 고 비어 있습니다.  
  
 모든 메서드를 재정의 하 여 파생된 클래스의 부분 정의 같은 만들기 `CirculationBook`.  생성 된 메서드와 모델링 프레임 워크에서 상속 된 메서드를 재정의할 수 있습니다.  
  
 요소의 모델 요소, 관계, 도형, 다이어그램, 및 연결선을 포함 한 모든 형식에 대해이 메서드를 사용할 수 있습니다.  다른 생성 된 클래스의 메서드를 재정의할 수도 있습니다.  ToolboxHelper 같은 항상 이중에서 파생 된 일부 클래스를 생성 합니다.  
  
### 사용자 지정 생성자  
 생성자는 재정의할 수 없습니다.  이중에서 파생 된 클래스에도 생성자에서 파생 된 클래스 여야 합니다.  
  
 직접 생성자를 제공 하려면 설정 하 여 이렇게 수 있습니다 `Has Custom Constructor` 도메인 클래스는 DSL 정의에 대 한.  클릭 하면  **모든 템플릿 변환**에서 생성 된 코드를 해당 클래스의 생성자에 포함 되지 않습니다.  누락 된 생성자를 호출 하는 포함 됩니다.  솔루션을 빌드할 때 오류 보고가 됩니다.  주석에서 생성 된 코드를 제공 합니다 설명 합니다 오류 보고서를 두 번 클릭 합니다.  
  
 Partial 클래스 정의에서 생성 된 파일을 별도 파일로 작성 하 고 생성자를 제공 합니다.  
  
### 플래그가 지정 된 확장 지점  
 플래그가 지정 된 확장 포인트를 DSL 정의 속성 또는 사용자 정의 메서드를 제공할 것임을 나타내려면 확인란을 설정할 수 있습니다 가능 합니다.  사용자 지정 생성자는 하나의 예입니다.  설정을 예로 `Kind` 계산 된 열 또는 사용자 정의 저장소 또는 설정을 도메인 속성의  **사용자 정의 된** 연결 작성기에서 플래그.  
  
 각각의 경우에 플래그를 설정 하 고 코드를 다시 생성할 때 빌드 오류가 발생 합니다.  제공할 수 있습니다 설명 설명 합니다 오류를 두 번 클릭 합니다.  
  
### 규칙  
 트랜잭션 관리자는 지정 된 이벤트, 속성 변경 등 발생 한 트랜잭션이 끝나기 전에 실행 하는 규칙을 정의할 수 있습니다.  규칙 synchronism 저장소에 서로 다른 여러 요소 간에 유지 하기 위해 일반적으로 사용 됩니다.  예를 들어, 다이어그램은 모델의 현재 상태를 표시 하도록 규칙이 사용 됩니다.  
  
 규칙은 각 클래스 별로 정의 된, 코드가 포함 되지 않도록는 각 개체에 대 한 규칙을 등록 합니다.  자세한 내용은 [규칙에는 모델 내에서 변경 내용을 전파 하기](../modeling/rules-propagate-changes-within-the-model.md)를 참조하십시오.  
  
### 저장소 이벤트  
 모델링 저장소 등 고 특정 형식의 요소에 속성 값이 변경의 추가 및 삭제를 포함 하는 저장소에서 변경에 대 한 수신 대기를 사용할 수 있는 이벤트 메커니즘을 제공 합니다.  이벤트 처리기에서 해당 변경 내용이 트랜잭션 종료 후 호출 됩니다.  일반적으로이 이벤트 외부 저장소 리소스를 업데이트 하려면 사용 됩니다.  
  
### .NET 이벤트  
 일부 모양에는 이벤트를 구독할 수 있습니다.  예를 들어, 셰이프의 마우스 클릭을 수신할 수 있습니다.  각 개체에 대 한 이벤트를 구독 하는 코드를 작성 해야 합니다.  재정의 된 Initializeinstanceresources\(\)이이 코드를 작성할 수 있습니다.  
  
 일부 이벤트는 decorators 셰이프를 그리는 데 사용 되는 Shapefields에 생성 됩니다.  예제를 보려면 [방법: 모양 또는 데코레이터 클릭 가로채기](../Topic/How%20to:%20Intercept%20a%20Click%20on%20a%20Shape%20or%20Decorator.md)을 참조하십시오.  
  
 이러한 이벤트는 일반적으로 트랜잭션 내부 발생 하지 않습니다.  저장소를 변경 하는 경우 트랜잭션을 만들어야 합니다.